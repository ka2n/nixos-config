diff --git a/src/main.rs b/src/main.rs
index 49b153c..56d5d62 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -21,6 +21,7 @@ enum Ctrl {
     MoveToTag(u8, Option<String>),
     RestorePrevTags,
     MoveToNextMonitor,
+    Status(tokio::sync::oneshot::Sender<String>),
     MonitorAdded(Monitor),
 }

@@ -187,8 +188,22 @@ async fn handle_ctrl_socket(tx: mpsc::Sender<Ctrl>, stream: UnixStream) {
                         tx.send(Ctrl::MoveToNextMonitor).await.expect("send error");
                     },

+                    "status" => {
+                        let (resp_tx, resp_rx) = tokio::sync::oneshot::channel();
+                        tx.send(Ctrl::Status(resp_tx)).await.expect("send error");
+
+                        // Wait for response and write it back
+                        if let Ok(response) = resp_rx.await {
+                            use tokio::io::AsyncWriteExt;
+                            let _ = stream.write_all(response.as_bytes()).await;
+                            let _ = stream.write_all(b"\n").await;
+                            let _ = stream.flush().await;
+                        }
+                    },
+
                     _ => {},
                 }
+                buf.clear();
             },
         }
     }
@@ -358,6 +373,12 @@ fn handle_ctrl(state: &mut MonitorsState, msg: Ctrl) {
             }
         },

+        Ctrl::Status(resp_tx) => {
+            let (active_tags, occupied_tags, monitor) = state.get_status();
+            let response = format!("{{\"active_tags\": {:?}, \"occupied_tags\": {:?}, \"monitor\": {}}}", active_tags, occupied_tags, monitor);
+            let _ = resp_tx.send(response);
+        },
+
         Ctrl::MonitorAdded(monitor) => {
             tracing::info!("handle new monitor: {}", monitor.name);
             if let Err(err) = state.monitor_added_with_object(monitor) {
diff --git a/src/monitor.rs b/src/monitor.rs
index 77535af..a3e5b39 100644
--- a/src/monitor.rs
+++ b/src/monitor.rs
@@ -58,6 +58,24 @@ impl MonitorsState {
         s
     }

+    pub fn get_status(&self) -> (Vec<u8>, Vec<u8>, usize) {
+        let active_monitor = &self.monitors[self.active_monitor_index];
+        let visible_tags = active_monitor.state.visible_tags();
+        let occupied_tags = active_monitor.state.occupied_tags();
+
+        let mut active = vec![];
+        let mut occupied = vec![];
+        for i in 0..9 {
+            if visible_tags & (1 << i) != 0 {
+                active.push(i + 1);
+            }
+            if occupied_tags & (1 << i) != 0 {
+                occupied.push(i + 1);
+            }
+        }
+        (active, occupied, self.active_monitor_index)
+    }
+
     pub fn next_monitor(&self) -> u8 {
         let next_index = self.active_monitor_index + 1;
         if next_index < self.monitors.len() {
diff --git a/src/state.rs b/src/state.rs
index 906bfd5..c4c5b0c 100644
--- a/src/state.rs
+++ b/src/state.rs
@@ -62,6 +62,16 @@ impl State {
         self.visible_tags
     }

+    pub fn occupied_tags(&self) -> u32 {
+        let mut occupied = 0u32;
+        for (i, tag) in self.tags.iter().enumerate() {
+            if tag.window_addrs.len() > 0 {
+                occupied |= 1 << i;
+            }
+        }
+        occupied
+    }
+
     pub fn active_window(&self) -> Option<String> {
         match &self.active_window {
             Some(w) => Some(w.clone()),
